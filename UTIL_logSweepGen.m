function [sweep,inverseSweep t] = UTIL_logSweepGen(f1,f2,Fs,duration,fadeIn,fadeOut,preSilence,postSilence)

%modifcato in modo che restituisca l'inversa di sinesweeps come da
%http://www.jezwells.org/Matlab/logSweepGen.m
% function[sweep,inverseSweep] = logSweepGen(start,stop,duration,Fs);
% function to produce a logarithmic frequency sweep rising from the start
% frequency to stop frequency (both in Hz) for the duration T (in seconds).
% The sample rate (Fs) must also be specified
% See page 6 of "Simultaneous measurement of impulse response and distortion
% with a swept sine technique" - Angelo Farina for the equation used.
% The inverse sweep is generated by time-reversing the sweep and applying a
% -6dB per octave envelope
% t:        the time base 
% start:    start frequency of sweep
% stop:     stop frequency of sweep
% duration: duration of sweep in seconds
% Fs:       sample rate
% convolution of the sweep with its inverse will produce an impulse
% Note that a 100 ms ramp in and out is applied to the sweep to prevent start
% and stop transients, therefore the sweep should be as long as possible (e.g.
% many seconds)
% This implementation by Jez Wells, University of York, August 2006

if nargin==1
    sweepExcitationParameters=f1;
    Fs=sweepExcitationParameters.fs;
    duration=sweepExcitationParameters.duration;
    f2=sweepExcitationParameters.f2;
    fadeIn=sweepExcitationParameters.fadeIn;
    fadeOut=sweepExcitationParameters.fadeOut;
    preSilence=sweepExcitationParameters.presilence;
    postSilence=sweepExcitationParameters.postsilence;
    f1=sweepExcitationParameters.f1;
else
    if nargin < 5
        fadeIn=0.01;
        fadeOut=0.01;
        preSilence=1;
        postSilence=2;
    elseif nargin < 6
        fadeOut=0.01;
        preSilence=1;
        postSilence=2;
    elseif nargin < 7
        preSilence=1;
        postSilence=2;
    elseif nargin < 8
        postSilence=2;
    end
end

T=duration;
N_sample=T*Fs;
Ts=1/Fs;
N_sampleFadeIn=floor(fadeIn/Ts);
N_sampleFadeOut=floor(fadeOut/Ts);
N_preSilence=floor(preSilence/Ts);
N_postSilence=floor(postSilence/Ts);
preSilenceSig=zeros(N_preSilence,1);
postSilenceSig=zeros(N_postSilence,1);

disp(['UTIL_logSweepGen: Generating a sweep signal from ' num2str(f1) 'Hz to ' num2str(f2) ' of ' num2str(duration+preSilence) ...
    ' sec. @ ' num2str(Fs) 'Hz (presilence=' num2str(preSilence) ' fadein=' num2str(fadeIn) ' fadeout=' num2str(fadeOut) 'sec.)' ]);
%Generate pure sweep;
t=0:Ts:(N_sample-1)*Ts;
w1 = 2*pi*f1;
w2 = 2*pi*f2;
espArg=(t./T)*log(w2/w1);
espResult=exp(espArg)-1;
K=(w1*T)/log(w2/w1);
sweep=sin(K.*espResult);

%Apply fadeIn
N=1/(N_sampleFadeIn-1);
envFadeIn=N*(1:N_sampleFadeIn)-N;
sweep(1:N_sampleFadeIn)=sweep(1:N_sampleFadeIn).*envFadeIn;

%Apply fadeOut
N=1/(N_sampleFadeOut-1);
envFadeOut=rot90(N*(1:N_sampleFadeOut)-N,2);
L=length(sweep);
sweep(L-N_sampleFadeOut+1:L)=sweep(L-N_sampleFadeOut+1:L).*envFadeOut;

%InsertPresilence and post silence
sweep=[preSilenceSig' sweep postSilenceSig'];

%Recalculate t
N_sample=length(sweep');
t=0:Ts:(N_sample-1)*Ts;


inverseSweep = rot90(sweep,-2);
envelope = logspace(log10(1),log10(f1/f2),N_sample);
inverseSweep = envelope.*inverseSweep;

sweep=sweep';
inverseSweep=inverseSweep';